# Epoll 复用模块
**处理准备就绪的fd**

1. epoll_wait() 返回很多个准备就绪的fd,每个使用单线程的方式处理的效果很慢，所以我们可以考虑直接引入 线程池，把所有的epoll_wait准备就绪的fd 分散给线程池使用
2. 或者处理系统http 请求和相应当中的read(),write()方法,将read()或write() 函数以及参数封装成为一个任务,比如在我们实现部分当中 thread_task封装

**数据为何需要内核准备好**
五层网络通信，我们就可以知道的， 数据从底层的网卡，到socket缓存区，然后再到用户缓存区，我们都知道在Linux I/O 当中

**上述关系当中**

epoll() 系列和read() 的关系是怎样的情况，我的理解是这样的

就是read()当中我们需要从内核当中读取数据，然后我们要知道在哪个fd上面有数据可读和可写，而epoll系列就是这样的函数，她返回准备就绪的fd,epoll_wait(), 然后我们就可以对epoll_wait()返回结果**fd**进行一个read 或者 write;

epoll_wait() **探子**返回一个fd结果（有很多个），我们要从这个结果集合当中找出我们关注的**我们在监听的listenfd** 所以使用判断events[i].data.fd = listenfd，然后在处理

究竟每个准备就绪的fd 我们是使用read() 调用还是write() 调用函数，我们在向epoll_clt注册fd的时候就决定好了的，使用events[i].events&EPOLLIN 进行判断，调用read(fd，)

所以这个整个逻辑我们要情况，

**epoll_wait采用ET还是LT**

两者的基本区别

比如一个fd=10 有2kb的数据，将fd=10分配一个线程来处理；但是该线程只是处理（只读)1kb，还有1kb没有读完，接下来就会出现ET和LT模式的区别


1. 如果采用ET，下次epoll_wait是不会再返回fd=10 这个文件描述符的，触发在fd=10这个文件描述符上面又有了新加入的数据，变成3kb的数据（ET只有在fd状态进行更新才触发）


2. 如果采用LT, 下面epoll_wait 还会返回fd=10这个文件描述符，多次触发返回，不断在就绪list当中返回（只要有数据就还一直触发）



使用LT模式意味着只要fd处于可读或者可写状态，每次epoll_wait都会返回该fd，这样的话会带来很大的系统开销，且处理时候每次都需要把这些fd轮询一遍，如果fd的数量巨大，不管有没有事件发生，epoll_wait都会触发这些fd的轮询判断。

 