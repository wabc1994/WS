# Epoll 复用模块
**处理准备就绪的fd**
什么叫做fd 准备就绪状态，主要包括三个
1. 可读
2. 可写
3. 新事件的到来情况




1. epoll\_wait()返回很多个准备就绪的fd,每个使用单线程的方式处理的效果很慢，所以我们可以考虑直接引入线程池，把所有的epoll\_wait准备就绪的fd 分散给线程池使用
2. 或者处理系统http 请求和相应当中的read(),write()方法,将read()或write() 函数以及参数封装成为一个任务,比如在我们实现部分当中 thread\_task封装

**数据为何需要内核准备好**
五层网络通信，我们就可以知道的，数据从底层的网卡，到socket缓存区，然后再到用户缓存区，我们都知道在Linux I/O 当中

**上述关系当中**

epoll() 系列和read()的关系是怎样的情况，我的理解是这样的

就是read()当中我们需要从内核当中读取数据，然后我们要知道在哪个fd上面有数据可读和可写，而epoll系列就是这样的函数，她返回准备就绪的fd,epoll\_wait(), 然后我们就可以对epoll\_wait()返回结果**fd**进行一个read 或者 write;

epoll\_wait() **探子**返回一个fd结果（有很多个），我们要从这个结果集合当中找出我们关注的**我们在监听的listenfd** 所以使用判断events[i].data.fd = listenfd，然后在处理

究竟每个准备就绪的fd 我们是使用read() 调用还是write() 调用函数，我们在向epoll\_clt注册fd的时候就决定好了的，使用events[i].events&EPOLLIN 进行判断，调用read(fd，)

所以这个整个逻辑我们要情况，

**epoll_wait采用ET还是LT**

两者的基本区别

比如一个fd=10 有2kb的数据，将fd=10分配一个线程来处理；但是该线程只是处理（只读)1kb，还有1kb没有读完，接下来就会出现ET和LT模式的区别


1. 如果采用ET，下次epoll\_wait是不会再返回fd=10 这个文件描述符的，触发在fd=10这个文件描述符上面又有了新加入的数据，变成3kb的数据（ET只有在fd状态进行更新才触发）


2. 如果采用LT, 下面epoll\_wait 还会返回fd=10这个文件描述符，多次触发返回，不断在就绪list当中返回（只要有数据就还一直触发）



使用LT模式意味着只要fd处于可读或者可写状态，每次epoll\_wait都会返回该fd，这样的话会带来很大的系统开销，且处理时候每次都需要把这些fd轮询一遍，如果fd的数量巨大，不管有没有事件发生，epoll\_wait都会触发这些fd的轮询判断。


# epoll ET注意事项
# 1. ET模式下面的accept正确方式

[![VbIqXQ.md.png](https://s2.ax1x.com/2019/06/18/VbIqXQ.md.png)](https://imgchr.com/i/VbIqXQ)

# 2. ET模式下面正确读写事件
1. 采用一直读策略或者一直写的策略，知道返回0或者返回EAGIN 错误代码，
2. ET模式如果本次没有读完数据，那么正确的做法是下次接着注册该事件


**正确的方式** 
1. 只要可读，就一直读，直到返回0，或者 errno = EAGAIN 
2. 只要可写, 就一直写, 直到数据发送完, 或者 errno = EAGAIN 


# 读到一半了然后有新的事件到来边缘触发
重点在于采用什么方式解决这个问题，从几个点的问题

1. 采用EPOLLONESHOT 方法， 读取一次之后就从epoll当中删除该文件描述符，然后再手动重新添加epoll\_clt\_mod in   
2. 从避免多个进程读写同一个socket这个角度来回答这个问题