# spring-boot-seckill项目总结




项目总体是怎么搞的？


1. 流量肖峰 排队方式
- 消息队列，同步请求转换为异步请求，起到缓冲的作用
- 利用
- 
2. 分层过滤，漏桶，对不符合请求的进行过滤
3. 答题系统，减缓请求的发出，利用图片进行一些干扰活动，防止各种秒杀器的基础使用情况

## com模块

### AOP 
主要用于在页面限流模块


## 限流模块
限流模块主要可以在两个地方来做

1. 可以在网关层面做api， 比如spring cloud nignx,
2. 也可以在应用层的AOP实现


## 排队
将用户的请求变成有序的情况，顺便大量的请求搞成有序的一个队列，实现方式主要有下面几种情况，方便程序进行一个有序的处理。

1. 利用线程池加锁等待也是一种常用的排队方式,阻塞队列LinkedBlockingQueue，100设置固定
2. 先进入先出，先进后出等常用的内存排队队列算法的实现方式，（内存队列）
3. 把请求序列化到文件中，然后在顺序读文件（比如基于MySQL binlog的同步机制）来做回复请求
4. 分布式消息队列，分布在不同的机器上面，分布式消息队列与内存队列是有区别的情况，


### Disrupto模块应用
为何要使用Disruptor
>基于内存的无锁队列，可以高效地实现生产者和消费者的情况，

1. ringbuffer设置为1024个大小的情况


## nginx限流模块开发

用户前端请求先经过CDN加速，然后再进入nginx限流模块， nginx限流主要是通过在controller层来实现, nginx主要是API接口进行一个限流

## 分布式锁模块






# others
1. @service注解是放在实现类前面
2. @Autowired使用在接口前面的勤快过，既可以操作普通类型，也可以操作bean


接口就是真正在使用的


## websocket推送到前台的情况

用户抢单的消息被压缩进入消息队列，同步变成了异步的方式，因此客户端如何知道自己的抢购是否成功还是失败了，所有就有了下面的websocket， 

抢单成功之后将利用websocket推送到前端，实现服务器向用户浏览器的消息推送环节,

websocket主要是在服务器和客户端浏览器之间进行一个通信，实现任务的推胸

## 公共模块

- 账号服务模块设计
- 


# 疑问
就是有个一个问题，如何是消息队列，谁是消息的生产者，谁是消费者的问题，情况情况


## 如何解决库存超卖问题

**问题背景**
一开始一共100个商品，现在成功被抢购了99件，库存只有1个了，但是此时要是有很多了客户流量请求到系统，如果同时读取到库存为1，就代表可以购买成功， 这样就会出现超卖的问题？

一个抢购成功包括两个步骤

1. 减库存
2. 创建秒杀订单成功,也就是要在数据库当中创建一个章userid, goodid成功，然后持久化到磁盘当中去，也就是要落地

要保证上述两个步骤是一个原子操作， 

解决之道：声明式事务情况,情况