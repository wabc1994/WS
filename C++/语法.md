# 简单记录一些核心

## 多态
1.  虚表与类对应，只有一个，因此虚函数地址也是只有一个，虚指针是每个虚类对象都有，因此构造函数不能声明为虚函数，
2. 如何派生类重写基类的，那么派生类的虚表当中也是也会多一个指针，
3. share_ptr 包括两个东西，一个引用计数，一个是指向的对象， 引用计数是原子操作， 无需考虑多线程安全的问题，而指向的对象不是线程安全的，所以必须加锁操作，


有什么函数不能声明为虚函数
1. 一种是构造函数，
2. 另一个种是static函数，因此static 是属于整个类的，而虚函数-虚指针是属于是对象级别的，所有跟类级别有关就不能申明为static 情况


 虚函数的调用关系：this -> vptr-> vtable ->virtual function
 
 this 指针是属于对象的，static 级别的东西不属于类对象或者类实例，情况

# 如何回答内联函数？
>主要是与函数调用过程当中频繁进stack和出stack的开销问题，如何函数执行的时间比较短，甚至于出stack和入stack的开销好小的话，并且如果程序在for 循环当中涉及到一个函数调用，一直调用，有可能出现stack溢出的问题，这就带来性能问题，效率调低，然后将一个函数申明为inline后，就会直接将代码段拷贝到函数调用处，


- 函数调用要开辟一个函数stack 问题
- 内联函数只是对编译器的一种建议而已
- 使用建议：将函数


什么函数不能是内联函数
>虚函数作为动态绑定实现多态的时候不能声明为内联函数，因为内联函数是在编译期间确定的，而虚函数是在程序运行过程当中才决定的类型的，用来实现动态绑定，

# 迭代器失效的问题

前提知识：容器和跌大气是分开定义的，定义容器然后在end() begin(）对迭代器进行一个赋值操作，

1. 主要是内存分配的问题，序列化容器vector 或者list容器在删除一个元素之后，会导致当前的迭代器以及后面的迭代器全部失效那种，


1. vector序列性容器使用 返回 容器删除迭代器后返回一个迭代器的方法来做
2. map类型的迭代器使用i++后缀自增操作，map.erase(iter++), 先执行迭代器i++ 操作， 然后返回i++ 之前的原值情况，然后再执行容器的删除迭代器操作

# 四种类型转换
 1. dynamic\_cast  跟c++的多态，虚函数连接起来，主要是在基类转换为子类的过程当中的情况
 2. statci\_cast 静态类型 主要是使用在基础数据类型里面的转换 