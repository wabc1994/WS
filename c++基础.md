# c++语言问题
- c++多态实现
	- 动态绑定
	- 虚函数
	- 虚表(类)
	- 虚指针vptr(对象)
	- 将子类的对象赋值给父类的指针或者引用

- static_cast<int>类型转换
>C++的多态性用一句话概括就是：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数
>
>
>


静态多态主要是指函数参数不同产生的多态性，是在编译阶段可以识别的一种多态机制，而运行时多态则主要用于基类指针指向派生类对象时，可以通过**基类指针直接调用派生类的对象函数**，当然这种多态是通过虚函数实现的。
 
 [参考链接一](https://www.cnblogs.com/cxq0017/p/6074247.html)
 
- c++ 的编译过程

- c++和Java区别


# 析构函数为何要设计为虚函数
虚函数主要是从多态的角度来考虑，

编译器总是根据类型来调用类成员函数。基类指针或者引用可以指向一个派生类对象。这样c++ 不管这个基类指针指向的是基类对象
还是派生类的对象，最后调用的都是基类的析构函数，而不是派生类的，**问题就出在这里，如果我们的对象依靠派生类的析构函数来释放资源，而没有重载析构函数，那么就会出现资源泄漏，导致内存泄漏，不能正常得释放资源**

**派生类的析构函数不会被调用的**

**解决方法**
将析构函数定义为虚函数，那么在使用的时候就实现了多态，可以调用派生类的析构函数，正确得释放掉资源，

**为何构造函数不能进行定义为虚函数**
[为什么C++的构造函数不可以是虚函数，而析构函数可以是虚函数](https://blog.csdn.net/zhang2531/article/details/51218149)

**为何c++不把析构函数默认设置为虚函数的**
1. 兼容性
2. 内存空间的考虑

# 菱形基础
问题：二异性，

1. 作用域
2. 虚继承，保证只有基类的唯一副本，只有一份，而不是多分，

# 虚表vtable，虚指针vptr、虚函数

虚指针：定义对象时候在数据域生成，指向该类的虚函数表，虚函数表存储的是虚函数的地址，这样就达到了根据类型来调用正确的函数的目的，相当于一寻路的过程，

## 基础概念
1. 用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。 
2. 存在虚函数的类都有一个一维的虚函数表叫做虚表。每一个类的对象都有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。 
3. 多态性是一个接口多种实现，是面向对象的核心。分为编译多态性和运行多态性。 
4. 运行多态用虚函数来实现，结合动态绑定。 
5. 纯虚函数是虚函数再加上=0。并且该函数只有声明，没有实现。 
6. 抽象类是指包括至少一个纯虚函数的类。

## 

编译器在编译的时候，发现Base类中有虚函数，此时编译器会为每个包含虚函数的类创建一个虚表（即vtable），该表是一个一维数组（而不是一个链表），在这个数组中存放每个虚函数的地址。由于Base类和Derive类都包含了一个虚函数func()，编译器会为这两个类都建立一个虚表。 

[(6条消息)虚函数，虚指针和虚表详解 - Panda - CSDN博客](https://blog.csdn.net/qq_34484472/article/details/78232465)

## 什么类不能继承
1. 将构造函数和虚构函数声明为private
2. 友元类函数不能被继承
3.  