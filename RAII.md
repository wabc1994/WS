# RAII
资源获取即初始化，resource acquisition is initialization, 


在系统中，资源是有限的，一旦用完必须归还给系统，否则可能会造成资源耗尽或其他问题。例如，动态分配的内存如果用完不释放会造成内存泄漏。

这里说的资源不仅仅是指内存，还包括其他，例如文件描述符、网络连接、数据库连接、互斥锁等。

RAII当中的资源是指多个种类的情况

**为何要使用RAII方式**

RAII 的核心简单来说，就是为了防止内存泄漏，资源泄漏等情况产生的一种编程技巧， 我们平常在编程的过程当中，经常碰到申请堆内存。 在这些情况下面我们需要手动释放我们之前申请的资源(有借有还)。 但是由于程序出现异常获取提前return，导致程序没有运行到释放资源的代码块，导致内存泄漏等情况


**如何确保资源能够一定释放**

我们知道类当中有构造函数和析构函数， 这两个东西如果我们没有定义的话，编译器会调用默认的， 所以我们可以把要申请、 使用和释放的资源分别放在类的的构造函数和析构函数当中， 这两个函数反正一定会使用，这样就确保了我们申请的资源最后都一定会得到释放，

>RAII能让我们优雅的做完释放资源这件事。C++标准保证任何情况下，已构造的对象最终会销毁，即它的析构函数最终一定会被调用。我们前面说过，“借”了，一定要“还”。注意到那两个红色的“一定”了吗？一个是C++中一定会调用的函数，一个是我们一定要做的事。那我们把一定要做的事情放到一定会调用的函数中可以吗？这样我们就保证了一定要做的事最终一定会发生！

   没错，RAII就是利用析构函数一定会被调用的特性(不管是在return还是在异常退出的情况下)，将释放资源的代码写到类的析构函数中。在类对象初始化的时候，将资源传入该类对象中“托管”，并利用类对象最终调用析构函数将托管的资源释放掉。

 这样，资源的生命周期就等同于类对象的生命周期。
 
 
 
# 实现步骤
1. 定义一个属性变量(资源)
2. 构造函数(将资源传入对象初始化资源，实现托管)
3. 析构函数（当类对象生命周期结束（或异常退出时，在进入catch语句前，会自动调用对象析构函数），调用其析构函数，托管的资源在析构函数中同时也释放掉）


 



# 应用在项目当中
1. 智能指针shared_ptr 和weak_ptr
2. 自定义RAII C++实现范围互斥锁，安全上锁和释放锁



# 互斥锁的使用

互斥器的使用

- 用 RAII 手法封装 mutex 的创建、销毁、加锁、解锁这四个操作。保证锁的生效期间等于一个作用域（scope）。
- 只用非递归的 mutex（即不可重入的 mutex）。
- 不手工调用 lock() 和 unlock() 函数，一切交给栈上的 Guard 对象的构造和析构函数负责（Scoped Locking）。
- 在每次构造 Guard 对象的时候，思考一路上（调用栈上）已经持有的锁，防止因加锁顺序不同而导致死锁。


RAII技术，很有意思，与其说是一个技术，不如说是一个编程上的窍门。我们平常编程时也可能会用到，在stl模板库里也有体现，但可能我们并不知道它的名字。


# 参考链接
[一种优雅的资源管理技术——RAII ](https://blog.csdn.net/u013378438/article/details/30336333)

[RAII封装mutex ](https://blog.csdn.net/liuxuejiang158blog/article/details/10953305)
